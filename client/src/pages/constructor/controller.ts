import createElemWithClass from '../../helpers/createElementWithClass';import { MOCK_INGREDIENTS } from '../../constants';import { ILoadRecipeCard, IUserResponse } from '../../types';import * as formHandler from '../../helpers/loginFormHandlers';import { recipesLoadConfigInit } from './config';import loadCardsContent from '../../features/loadCards';import * as recipesService from '../../api/recipesService';import { renderCards } from '../../features/renderCards';import { handleSaveFavoriteButtons } from '../../features/cardButtonsHandler';const recipesLoadConfig = { ...recipesLoadConfigInit };const constructorInput = document.getElementById('constructor-input') as HTMLInputElement;const dropdownMenu = document.querySelector('.ingredient-options') as HTMLElement;const optionsHolder = document.getElementById('relevant-options') as HTMLElement;const chosenIngredientsBox = document.getElementById('chosen-ingredients') as HTMLElement;const boxEmptyMessageElement = document.getElementById('is-empty-message') as HTMLElement;const addProductsBtn = document.getElementById('add-from-list') as HTMLElement;const searchRecipesBtn = document.getElementById('constructor-search') as HTMLButtonElement;const relevantRecipesBlock = document.getElementById('relevant') as HTMLElement;const lackOneRecipeBlock = document.getElementById('lack-1') as HTMLElement;const lackTwoRecipesBlock = document.getElementById('lack-2') as HTMLElement;const lackThreeRecipesBlock = document.getElementById('lack-3') as HTMLElement;const failureSearchBlock = document.getElementById('failure') as HTMLElement;export function addConstructorListeners(dropdownIngredients: string[], chosenList: string[]) {  formHandler.addUserButtonListener();  formHandler.addRegisterFormListener();  formHandler.addSignInFormListener();  chosenIngredientsBox.addEventListener('click', e => {    const target = e.target as HTMLElement;    if (target.classList.contains('constructor-ingredient__delete')) {      const chosenElem = (e.target as HTMLElement).closest('.constructor-ingredient') as HTMLElement;      const ingredientName = (chosenElem.querySelector('.constructor-ingredient__name') as HTMLElement).innerHTML;      if (chosenElem) {        removeIngredientFromChosen(chosenElem);        deleteIngredientFromList(ingredientName, chosenList);        addIngredientToOptions(chosenElem, dropdownIngredients);      }    }    if (chosenIngredientsBox.querySelectorAll('.constructor-ingredient').length === 0) {      showBoxIsEmptyMessage();    } else {      removeBoxIsEmptyMessage();    }  });  constructorInput.addEventListener('click', () => {    renderIngredientOptions(dropdownIngredients);    dropdownMenu.classList.add('is-active');  });  constructorInput.addEventListener('input', () => {    dropdownMenu.classList.add('is-active');    const relevantIngredients = filterOptions(dropdownIngredients, constructorInput.value.trim().toLocaleLowerCase());    relevantIngredients.length ? renderIngredientOptions(relevantIngredients) : renderMessage('Sorry, nothing matches');  });  document.body.addEventListener('click', e => {    const target = e.target as HTMLElement;    if (!target.classList.contains('ingredient-options__item') && target.id !== 'constructor-input') {      dropdownMenu.classList.remove('is-active');    }  });  constructorInput.addEventListener('keypress', e => {    if (e.key === 'Enter') {      moveIngredientToChosen(constructorInput.value, dropdownIngredients, chosenList);    }  });  optionsHolder.addEventListener('click', e => {    const target = e.target as HTMLElement;    if (target.classList.contains('ingredient-options__item')) {      moveIngredientToChosen(target.innerText, dropdownIngredients, chosenList);    }  });  addProductsBtn.addEventListener('click', () => addUsersProducts(dropdownIngredients, chosenList));  searchRecipesBtn.addEventListener('click', () => fetchRecipes(chosenList));}export function renderIngredientOptions(options: string[]): void {  optionsHolder.innerHTML = '';  options.forEach(item => {    const listElem = createElemWithClass('li', 'ingredient-options__item');    listElem.id = item;    listElem.innerText = item;    optionsHolder.append(listElem);  });}function renderMessage(message: string): void {  optionsHolder.innerText = message;}function filterOptions(options: string[], value: string) {  return options.filter(item => item.includes(value));}function addIngredientToList(productName: string, list: string[]) {  if (MOCK_INGREDIENTS.includes(productName) && !list.includes(productName)) {    list.push(productName);    list.sort();  }}function deleteIngredientFromList(productName: string, list: string[]) {  const productIndex = list.findIndex(elementName => elementName === productName.toLowerCase());  const deleteCount = productIndex === -1 ? 0 : 1;  list.splice(productIndex, deleteCount);}function addIngredientToChosenBox(ingredient: string): void {  const ingredientEl = createElemWithClass('div', 'constructor-ingredients__item', 'constructor-ingredient');  ingredientEl.innerHTML = `    <span class="constructor-ingredient__name">${ingredient}</span>    <div class="constructor-ingredient__delete"></div>  `;  chosenIngredientsBox.append(ingredientEl);}function moveIngredientToChosen(str: string, dropdownIngredients: string[], chosenList: string[]): void {  const ingredient = str.trim().toLowerCase();  if (MOCK_INGREDIENTS.includes(ingredient)) {    addIngredientToChosenBox(ingredient);    addIngredientToList(ingredient, chosenList);    removeBoxIsEmptyMessage();  }  deleteIngredientFromList(ingredient, dropdownIngredients);  constructorInput.value = '';  renderIngredientOptions(dropdownIngredients);  constructorInput.focus();}function removeIngredientFromChosen(elem: Element): void {  chosenIngredientsBox.removeChild(elem);}function addIngredientToOptions(elem: Element, dropdownIngredients: string[]): void {  const chosenElemName = (elem.querySelector('.constructor-ingredient__name') as HTMLElement).innerText;  dropdownIngredients.push(chosenElemName);  dropdownIngredients.sort();}export function showBoxIsEmptyMessage() {  boxEmptyMessageElement.classList.remove('hidden');}function removeBoxIsEmptyMessage() {  boxEmptyMessageElement.classList.add('hidden');}function addUsersProducts(dropdownIngredients: string[], chosenList: string[]) {  const userObject = JSON.parse(localStorage.getItem('user') || 'null') as IUserResponse;  const prevAddedProductList = chosenList;  if (userObject) {    userObject.products.own.forEach(product => {      if (!prevAddedProductList.includes(product)) {        moveIngredientToChosen(product, dropdownIngredients, chosenList);      }    });  }}function toggleBlockVisibility(block: HTMLElement, visible: boolean) {  if (visible) {    block.classList.remove('hidden');  } else {    block.classList.add('hidden');  }}async function fetchRecipes(chosenList: string[]) {  if (chosenList.length > 0) {    recipesLoadConfig.queryOptions.ingredientsAll = chosenList.slice();    await loadRecipesPage(recipesLoadConfig);  }}async function loadRecipesPage(recipesLoadConfig: ILoadRecipeCard) {  const recipesData = await loadCardsContent(recipesLoadConfig, recipesService.getRecipes);  if (recipesData.length > 0) {    toggleBlockVisibility(relevantRecipesBlock, true);    toggleBlockVisibility(failureSearchBlock, false);    const userObject = JSON.parse(localStorage.getItem('user') || 'null');    renderCards(recipesData, recipesLoadConfig, userObject);    addRecipeButtonsListeners();  } else {    toggleBlockVisibility(relevantRecipesBlock, false);    toggleBlockVisibility(lackOneRecipeBlock, false);    toggleBlockVisibility(lackTwoRecipesBlock, false);    toggleBlockVisibility(lackThreeRecipesBlock, false);    toggleBlockVisibility(failureSearchBlock, true);  }}function addRecipeButtonsListeners() {  const recipes = document.querySelectorAll('.card');  recipes.forEach(recipe => {    handleSaveFavoriteButtons(recipe, 'recipes');  });}